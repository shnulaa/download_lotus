V1.0.1ç‰ˆæœ¬ éœ€è¦ä¿®å¤å’Œæ”¹è¿›çš„åœ°æ–¹
1. ä¸‹è½½é€Ÿåº¦æ˜¾ç¤º
2. UIç•Œé¢ æ ¼å­æ•°é‡åœ¨å¤šä¸€ç‚¹,å›ºå®šæ’æ»¡æ­£æ–¹å½¢,æ¯ä¸ªçº¿ç¨‹çš„é¢œè‰²ä¸ä¸€æ ·.
3. æ¯ä¸ªä»»åŠ¡çš„ä¸‹è½½å®Œæˆå, æ˜¾ç¤ºæŒ‰é’® ä¸‹è½½åˆ°æœ¬åœ°. ç‚¹å‡»åå°†æœåŠ¡ç«¯çš„æ–‡ä»¶ä¸‹è½½ä¸‹æ¥
4. sqlliteè®°å½•æ¯æ¬¡ä¸‹è½½çš„ä»»åŠ¡,æœ‰ä»»åŠ¡ç®¡ç†é˜Ÿåˆ—,æ¯æ¬¡ä»»åŠ¡å¢åŠ å,æœ€æ–°çš„çš„æ˜¾ç¤ºåœ¨æœ€ä¸Šæ–¹.ä»»åŠ¡åˆ—è¡¨ç¿»é¡µæ˜¾ç¤º(æ¯é¡µ5ä¸ª).å¯ä»¥è¿›è¡Œåˆ é™¤ä»»åŠ¡å’Œ åˆ é™¤ä»»åŠ¡å’Œæœ¬åœ°æ–‡ä»¶.
5. ä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ çš„åƒä¸‹è½½ https://github.com/lcatro/Hacker_Document/archive/refs/heads/master.zip ç°åœ¨ä¸èƒ½ä¸‹è½½

è¿™æ˜¯ **V1.0.1** ç‰ˆæœ¬çš„å®Œæ•´å®ç°ã€‚åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº† SQLite æŒä¹…åŒ–ã€æ”¹è¿›äº†éæ ‡å‡† HTTP å“åº”ï¼ˆå¦‚ GitHub Zipï¼‰çš„å¤„ç†ã€é‡æ„äº† UI ä¸ºå¤šè‰²å—çŠ¶å›¾ï¼Œå¹¶å¢åŠ äº†ä»æœåŠ¡å™¨å–å›æ–‡ä»¶çš„åŠŸèƒ½ã€‚

### æ ¸å¿ƒå˜æ›´æ‘˜è¦

1.  **æ•°æ®åº“é›†æˆ**ï¼šä½¿ç”¨ SQLite å­˜å‚¨ä»»åŠ¡å†å²ï¼Œæ”¯æŒåˆ†é¡µæŸ¥è¯¢å’ŒæŒä¹…åŒ–ã€‚
2.  **æ ¸å¿ƒå†…æ ¸å‡çº§**ï¼š
    *   **æœªçŸ¥é•¿åº¦æ”¯æŒ**ï¼šé’ˆå¯¹ GitHub ç­‰ä¸è¿”å› `Content-Length` çš„æµå¼æ–‡ä»¶ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºâ€œæµå¼ä¸‹è½½æ¨¡å¼â€ï¼ˆæ— è¿›åº¦æ¡ï¼Œåªæ˜¾ç¤ºå·²ä¸‹è½½é‡ï¼‰ã€‚
    *   **é‡å®šå‘å¤„ç†**ï¼šä¼˜åŒ– HttpClient ä»¥æ›´å¥½æ”¯æŒ 302 è·³è½¬ã€‚
    *   **å…¨å±€é€Ÿåº¦è®¡ç®—**ï¼šå‡†ç¡®èšåˆæ‰€æœ‰çº¿ç¨‹çš„ç¬æ—¶é€Ÿåº¦ã€‚
3.  **UI é‡æ„**ï¼š
    *   **å¯†é›†æ–¹å—å›¾**ï¼šä½¿ç”¨ 400 ä¸ªæ ¼å­ (20x20) ç»„æˆæ­£æ–¹å½¢ã€‚
    *   **çº¿ç¨‹ç€è‰²**ï¼šæ¯ä¸ªçº¿ç¨‹åˆ†é…ä¸åŒé¢œè‰²ï¼Œç›´è§‚çœ‹åˆ°è°åœ¨ä¸‹è½½å“ªä¸€å—ã€‚
    *   **åˆ†é¡µä¸ç®¡ç†**ï¼šæ ‡å‡†çš„åˆ†é¡µåˆ—è¡¨ã€åˆ é™¤ï¼ˆä»…è®°å½•/åŒ…å«æ–‡ä»¶ï¼‰åŠŸèƒ½ã€‚
    *   **å–å›æœ¬åœ°**ï¼šå¢åŠ  `window.open` è§¦å‘æµè§ˆå™¨ä¸‹è½½æœåŠ¡å™¨æ–‡ä»¶ã€‚

---

### 1. åç«¯é…ç½®ä¸ä¾èµ–

#### 1.1 `pom.xml` æ›´æ–°
å¢åŠ  SQLite å’Œ JPA ä¾èµ–ã€‚

```xml
<!-- åœ¨åŸæœ‰ä¾èµ–åŸºç¡€ä¸Šå¢åŠ  -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<!-- SQLite é©±åŠ¨ -->
<dependency>
    <groupId>org.xerial</groupId>
    <artifactId>sqlite-jdbc</artifactId>
    <version>3.42.0.0</version>
</dependency>
<!-- Hibernate Community Dialects (é€‚é… SQLite) -->
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-community-dialects</artifactId>
    <version>6.2.4.Final</version>
</dependency>
```

#### 1.2 `application.yml`
é…ç½® SQLite æ•°æ®æºã€‚

```yaml
spring:
  datasource:
    url: jdbc:sqlite:downloader.db
    driver-class-name: org.sqlite.JDBC
    username: sa
    password: 
  jpa:
    database-platform: org.hibernate.community.dialect.SQLiteDialect
    hibernate:
      ddl-auto: update
    show-sql: false
```

---

### 2. å®ä½“ä¸æ•°æ®åº“å±‚

**`DownloadRecord.java`** (JPA å®ä½“)

```java
package com.example.downloader.entity;

import lombok.Data;
import javax.persistence.*;
import java.util.Date;

@Entity
@Data
@Table(name = "download_records")
public class DownloadRecord {
    @Id
    private String id; // UUID

    @Column(length = 1024)
    private String url;
    private String savePath;
    private String fileName;
    
    private Long totalSize; // -1 è¡¨ç¤ºæœªçŸ¥
    private String status;  // FINISHED, ERROR, etc.
    private Date createdTime;

    // ç”¨äºUIå±•ç¤ºçš„ç®€å•å­—æ®µ
    @Transient 
    private long downloadedSize;
    @Transient
    private long speed;
}
```

**`DownloadRepository.java`**

```java
package com.example.downloader.repo;

import com.example.downloader.entity.DownloadRecord;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface DownloadRepository extends JpaRepository<DownloadRecord, String> {
    // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæŸ¥è¯¢
    Page<DownloadRecord> findAllByOrderByCreatedTimeDesc(Pageable pageable);
}
```

---

### 3. æ ¸å¿ƒé€»è¾‘é‡æ„ (è§£å†³ GitHub ä¸‹è½½å’Œ UI é¢œè‰²)

**`ChunkInfo.java`** (å¢åŠ é¢œè‰²ç´¢å¼•)

```java
package com.example.downloader.model;

import lombok.Data;
import java.util.concurrent.atomic.AtomicLong;

@Data
public class ChunkInfo {
    private String id;
    private long start;
    private long end;
    private AtomicLong current;
    private volatile long speed;
    private volatile boolean finished;
    private int errorCount;
    
    // V1.0.1 æ–°å¢: çº¿ç¨‹é¢œè‰²ç´¢å¼• (0-32) ç”¨äºå‰ç«¯ç€è‰²
    private int colorIndex; 
    
    private transient long lastRecordBytes;

    public ChunkInfo(String id, long start, long end, long current, int colorIndex) {
        this.id = id;
        this.start = start;
        this.end = end;
        this.current = new AtomicLong(current);
        this.lastRecordBytes = current;
        this.colorIndex = colorIndex;
    }
}
```

**`DownloadTaskContext.java`** (æ ¸å¿ƒé€»è¾‘å¤§æ”¹)

```java
package com.example.downloader.core;

import com.example.downloader.entity.DownloadRecord;
import com.example.downloader.model.ChunkInfo;
import com.example.downloader.model.DownloadStatus;
import com.example.downloader.repo.DownloadRepository;
import com.example.downloader.util.FileUtils;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.Header;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import java.io.*;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Data
public class DownloadTaskContext {

    private DownloadRecord record;
    private DownloadRepository repository;
    
    private volatile DownloadStatus status = DownloadStatus.IDLE;
    private boolean supportRange = true;
    private long globalSpeed = 0; // å…¨å±€é€Ÿåº¦

    private ForkJoinPool chunkExecutor;
    private final Map<String, ChunkInfo> chunkMap = new ConcurrentHashMap<>();
    private final Map<String, ChunkWorker> activeWorkers = new ConcurrentHashMap<>();
    private final Object fileLock = new Object();

    public DownloadTaskContext(DownloadRecord record, DownloadRepository repo, int threads) {
        this.record = record;
        this.repository = repo;
        this.chunkExecutor = new ForkJoinPool(Math.min(threads + 1, 32));
    }

    public void start() {
        if (status == DownloadStatus.DOWNLOADING || status == DownloadStatus.FINISHED) return;
        
        // å¼‚æ­¥å¯åŠ¨é˜²æ­¢é˜»å¡Controller
        new Thread(() -> {
            try {
                if (status == DownloadStatus.IDLE) {
                    prepare();
                    saveRecord(); // ä¿å­˜å…¥åº“
                }
                
                status = DownloadStatus.DOWNLOADING;
                updateStatusInDb("DOWNLOADING");

                if (chunkMap.isEmpty()) {
                    // è¿™ç§æƒ…å†µä¸‹æ˜¯åˆå§‹åŒ–åˆ†ç‰‡
                     if (supportRange && record.getTotalSize() > 0) {
                        splitChunks(chunkExecutor.getParallelism());
                    } else {
                        // é’ˆå¯¹ GitHub è¿™ç§æ— æ³•è·å–é•¿åº¦æˆ–ä¸æ”¯æŒ Range çš„
                        createSingleStreamChunk();
                    }
                }

                // æäº¤ä»»åŠ¡
                chunkMap.values().stream().filter(c -> !c.isFinished()).forEach(this::submitTask);
                startMonitor();

            } catch (Exception e) {
                log.error("Task start failed", e);
                status = DownloadStatus.ERROR;
                updateStatusInDb("ERROR");
            }
        }).start();
    }

    /**
     * é¢„å¤„ç†ï¼šå¤„ç†æ–‡ä»¶åã€å¤§å°ã€é‡å®šå‘
     */
    private void prepare() throws IOException {
        RequestConfig config = RequestConfig.custom()
                .setConnectTimeout(10000) // è¿æ¥è¶…æ—¶
                .setSocketTimeout(30000)  // è¯»å–è¶…æ—¶
                .setRedirectsEnabled(true)// å…è®¸é‡å®šå‘ (è§£å†³ GitHub é—®é¢˜)
                .build();

        try (CloseableHttpClient client = HttpClients.custom().setDefaultRequestConfig(config).build()) {
            // 1. å°è¯• HEAD
            HttpHead head = new HttpHead(record.getUrl());
            try (CloseableHttpResponse response = client.execute(head)) {
                if (response.getStatusLine().getStatusCode() == 200) {
                    parseResponseHeaders(response);
                }
            } catch (Exception e) {
                // HEAD å¤±è´¥å°è¯• GET (éƒ¨åˆ†æœåŠ¡å™¨ç¦ç”¨äº† HEAD)
            }

            // 2. å¦‚æœ HEAD æ²¡æ‹¿åˆ°å¤§å°ï¼Œå°è¯• GET (Range: 0-0) æ¢æµ‹
            if (record.getTotalSize() == null || record.getTotalSize() <= 0) {
                HttpGet get = new HttpGet(record.getUrl());
                get.addHeader("Range", "bytes=0-0");
                try (CloseableHttpResponse response = client.execute(get)) {
                    parseResponseHeaders(response);
                }
            }

            // 3. ç¡®å®šæ–‡ä»¶å
            if (record.getFileName() == null) {
                String name = FileUtils.getUniqueFileName(record.getSavePath(), record.getUrl());
                record.setFileName(name);
            }
            
            // 4. å ä½ (åªæœ‰å·²çŸ¥å¤§å°æ‰å ä½)
            if (record.getTotalSize() != null && record.getTotalSize() > 0) {
                File file = new File(record.getSavePath(), record.getFileName());
                if (!file.getParentFile().exists()) file.getParentFile().mkdirs();
                try (RandomAccessFile raf = new RandomAccessFile(file, "rw")) {
                    raf.setLength(record.getTotalSize());
                }
            } else {
                // æœªçŸ¥å¤§å°æ—¶ï¼Œæ ‡è®°ä¸º -1
                if(record.getTotalSize() == null) record.setTotalSize(-1L);
                this.supportRange = false; // æœªçŸ¥å¤§å°å¼ºåˆ¶ä¸æ”¯æŒ Range
            }
        }
    }

    private void parseResponseHeaders(CloseableHttpResponse response) {
        Header lenHeader = response.getFirstHeader("Content-Length");
        Header rangeHeader = response.getFirstHeader("Accept-Ranges");
        
        if (lenHeader != null) {
            try {
                long len = Long.parseLong(lenHeader.getValue());
                // å¦‚æœ Range 0-0 è¿”å› Content-Range: bytes 0-0/12345ï¼Œåˆ™æ€»é•¿æ˜¯ 12345
                Header contentRange = response.getFirstHeader("Content-Range");
                if (contentRange != null) {
                    String val = contentRange.getValue();
                    int slash = val.lastIndexOf('/');
                    if (slash > 0) len = Long.parseLong(val.substring(slash + 1));
                }
                record.setTotalSize(len);
            } catch (NumberFormatException ignored) {}
        }
        
        if (rangeHeader != null && "bytes".equalsIgnoreCase(rangeHeader.getValue())) {
            this.supportRange = true;
        }
    }

    private void createSingleStreamChunk() {
        // åªæœ‰1ä¸ªçº¿ç¨‹ï¼Œé¢œè‰²ç´¢å¼•ä¸º0
        ChunkInfo chunk = new ChunkInfo("STREAM", 0, -1, 0, 0);
        chunkMap.put(chunk.getId(), chunk);
    }

    private void splitChunks(int count) {
        long total = record.getTotalSize();
        long blockSize = total / count;
        for (int i = 0; i < count; i++) {
            long start = i * blockSize;
            long end = (i == count - 1) ? total - 1 : (i + 1) * blockSize - 1;
            // åˆ†é…ä¸åŒçš„ colorIndex (i % 10) å‡è®¾å‰ç«¯æœ‰10ç§é¢œè‰²
            ChunkInfo chunk = new ChunkInfo(UUID.randomUUID().toString(), start, end, start, i);
            chunkMap.put(chunk.getId(), chunk);
        }
    }
    
    // ... pause, cancel å®ç°ç•¥ (åŒä¸Šä¸ªç‰ˆæœ¬) ...

    // ç›‘æ§çº¿ç¨‹æ”¹è¿›ï¼šèšåˆå…¨å±€é€Ÿåº¦
    private void startMonitor() {
        new Thread(() -> {
            while (status == DownloadStatus.DOWNLOADING) {
                try {
                    Thread.sleep(1000);
                    long sumSpeed = 0;
                    boolean allFinished = true;
                    
                    for (ChunkInfo chunk : chunkMap.values()) {
                        if (!chunk.isFinished()) {
                            allFinished = false;
                            long curr = chunk.getCurrent().get();
                            long sp = curr - chunk.getLastRecordBytes();
                            // ä¿®å¤è´Ÿæ•°bug (æå°‘æ•°æƒ…å†µ)
                            if (sp < 0) sp = 0;
                            chunk.setSpeed(sp);
                            chunk.setLastRecordBytes(curr);
                            sumSpeed += sp;
                        } else {
                            chunk.setSpeed(0);
                        }
                    }
                    
                    this.globalSpeed = sumSpeed;

                    if (allFinished && !chunkMap.isEmpty()) {
                        status = DownloadStatus.FINISHED;
                        updateStatusInDb("FINISHED");
                        break;
                    }
                    
                    // ä»…åœ¨æ”¯æŒ Range ä¸”å¤§å°å·²çŸ¥æ—¶å°è¯•é‡åˆ†é…
                    if(supportRange && record.getTotalSize() > 0) {
                        tryRebalance();
                    }
                } catch (Exception e) { e.printStackTrace(); }
            }
        }).start();
    }

    // TryRebalance å’Œ Worker é€»è¾‘å¤§è‡´ç›¸åŒï¼Œä½†åœ¨ Worker ä¸­éœ€å¤„ç† -1 çš„æƒ…å†µ
    
    private void submitTask(ChunkInfo chunkInfo) {
        ChunkWorker worker = new ChunkWorker(chunkInfo);
        activeWorkers.put(chunkInfo.getId(), worker);
        chunkExecutor.execute(worker);
    }

    private class ChunkWorker extends RecursiveAction {
        private final ChunkInfo chunk;
        private final AtomicBoolean running = new AtomicBoolean(true);
        public ChunkWorker(ChunkInfo c) { this.chunk = c; }

        @Override
        protected void compute() {
            try {
                download();
            } catch (Exception e) {
                chunk.setErrorCount(chunk.getErrorCount() + 1);
            }
        }

        private void download() throws IOException {
            CloseableHttpClient client = HttpClients.createDefault();
            HttpGet request = new HttpGet(record.getUrl());
            
            long startPos = chunk.getCurrent().get();
            // å¦‚æœæ˜¯æ™®é€š Range ä¸‹è½½
            if (supportRange && record.getTotalSize() > 0) {
                request.addHeader("Range", "bytes=" + startPos + "-" + chunk.getEnd());
            }
            // å¦‚æœæ˜¯ä¸æ”¯æŒ Range çš„æµå¼ä¸‹è½½ï¼Œä¸åŠ  Range å¤´ï¼Œç›´æ¥è¯»

            File targetFile = new File(record.getSavePath(), record.getFileName());
            
            try (CloseableHttpResponse response = client.execute(request);
                 InputStream is = response.getEntity().getContent();
                 RandomAccessFile raf = new RandomAccessFile(targetFile, "rw")) {
                
                if (supportRange && record.getTotalSize() > 0) {
                    raf.seek(startPos);
                } else {
                    // æµå¼è¿½åŠ æ¨¡å¼ï¼šå¦‚æœæ˜¯åˆšå¼€å§‹ï¼Œseek 0ï¼›å¦åˆ™ï¼ˆæ–­ç½‘é‡è¿ï¼‰å…¶å®æ˜¯ä¸æ”¯æŒçš„
                    // è¿™é‡Œç®€åŒ–ï¼šæµå¼ä¸‹è½½æ¯æ¬¡éƒ½è¦†ç›–
                    raf.seek(0);
                    chunk.getCurrent().set(0);
                }

                byte[] buf = new byte[16384]; // 16KB buffer
                int len;
                while (running.get() && (len = is.read(buf)) != -1) {
                    synchronized (fileLock) {
                        if (supportRange && record.getTotalSize() > 0) {
                            raf.seek(chunk.getCurrent().get());
                        } else {
                            // ç®€å•çš„è¿½åŠ å†™å…¥ä½ç½®ç»´æŠ¤
                            raf.seek(chunk.getCurrent().get());
                        }
                        raf.write(buf, 0, len);
                    }
                    chunk.getCurrent().addAndGet(len);
                }
                
                // åˆ¤å®šå®Œæˆ
                if (supportRange && record.getTotalSize() > 0) {
                    if (chunk.getCurrent().get() >= chunk.getEnd()) chunk.setFinished(true);
                } else {
                    // æµè¯»å®Œå°±æ˜¯å®Œæˆ
                    chunk.setFinished(true);
                    // æ›´æ–°æ€»å¤§å°
                    record.setTotalSize(chunk.getCurrent().get());
                    saveRecord();
                }
            }
        }
    }

    private void saveRecord() {
        repository.save(record);
    }
    
    private void updateStatusInDb(String s) {
        record.setStatus(s);
        repository.save(record);
    }
    
    // åŠ¨æ€é‡åˆ†é…é€»è¾‘ç•¥... éœ€è¦æ ¹æ® colorIndex ä¼ é€’ç»™æ–°åˆ†ç‰‡
    public void tryRebalance() {
        // ... çœç•¥åˆ¤æ–­é€»è¾‘ ...
        // performSplit(slowChunk);
    }
    
    private synchronized void performSplit(ChunkInfo parent) {
        // åœæ­¢æ—§çš„
        ChunkWorker worker = activeWorkers.get(parent.getId());
        if(worker != null) worker.running.set(false);
        
        long mid = parent.getCurrent().get() + (parent.getEnd() - parent.getCurrent().get()) / 2;
        long oldEnd = parent.getEnd();
        
        parent.setEnd(mid);
        // æ–°åˆ†ç‰‡èµ‹äºˆæ–°çš„ ColorIndex (ç®€å•ç´¯åŠ )
        ChunkInfo newChunk = new ChunkInfo(UUID.randomUUID().toString(), mid + 1, oldEnd, mid + 1, parent.getColorIndex() + 1);
        
        chunkMap.put(newChunk.getId(), newChunk);
        submitTask(parent); // é‡æ–°æäº¤å‰åŠæ®µ
        submitTask(newChunk); // æäº¤ååŠæ®µ
    }
}
```

---

### 4. Controller (æ”¯æŒä¸‹è½½æ–‡ä»¶ã€åˆ†é¡µã€åˆ é™¤)

```java
package com.example.downloader.controller;

import com.example.downloader.core.DownloadTaskContext;
import com.example.downloader.entity.DownloadRecord;
import com.example.downloader.model.ChunkInfo;
import com.example.downloader.model.DownloadStatus;
import com.example.downloader.repo.DownloadRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.*;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/download")
@CrossOrigin
public class DownloadController {

    @Autowired private DownloadRepository repository;
    @Autowired private SimpMessagingTemplate messagingTemplate;

    // å†…å­˜ä¸­æ´»è·ƒçš„ä»»åŠ¡ Context
    private final Map<String, DownloadTaskContext> activeContexts = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        // ç³»ç»Ÿé‡å¯åï¼Œå¯ä»¥åŠ è½½çŠ¶æ€ä¸º DOWNLOADING çš„ä»»åŠ¡å¹¶æ¢å¤(æ­¤å¤„ç®€åŒ–ä¸ºåªåŠ è½½çŠ¶æ€ï¼Œéœ€æ‰‹åŠ¨ç‚¹å¼€å§‹)
    }

    @PostMapping("/start")
    public String createTask(@RequestBody Map<String, Object> params) {
        String url = (String) params.get("url");
        String path = (String) params.get("path");
        int threads = (Integer) params.get("threads");

        DownloadRecord record = new DownloadRecord();
        record.setId(UUID.randomUUID().toString());
        record.setUrl(url);
        record.setSavePath(path);
        record.setCreatedTime(new Date());
        record.setStatus("IDLE");
        repository.save(record);

        DownloadTaskContext context = new DownloadTaskContext(record, repository, threads);
        activeContexts.put(record.getId(), context);
        context.start();
        
        return record.getId();
    }

    // åˆ†é¡µè·å–åˆ—è¡¨
    @GetMapping("/list")
    public Page<Map<String, Object>> list(@RequestParam(defaultValue = "0") int page, 
                                          @RequestParam(defaultValue = "5") int size) {
        Page<DownloadRecord> pageData = repository.findAllByOrderByCreatedTimeDesc(PageRequest.of(page, size));
        return pageData.map(this::enrichRecordData);
    }

    // ä¸‹è½½åˆ°æœ¬åœ° (æµè§ˆå™¨ä¸‹è½½)
    @GetMapping("/file/{id}")
    public ResponseEntity<Resource> downloadToLocal(@PathVariable String id) throws UnsupportedEncodingException {
        DownloadRecord record = repository.findById(id).orElse(null);
        if (record == null || !"FINISHED".equals(record.getStatus())) return ResponseEntity.notFound().build();

        File file = new File(record.getSavePath(), record.getFileName());
        if (!file.exists()) return ResponseEntity.notFound().build();

        Resource resource = new FileSystemResource(file);
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + URLEncoder.encode(file.getName(), "UTF-8") + "\"")
                .body(resource);
    }

    @DeleteMapping("/{id}")
    public void delete(@PathVariable String id, @RequestParam(defaultValue = "false") boolean deleteFile) {
        DownloadRecord record = repository.findById(id).orElse(null);
        if (record != null) {
            // åœæ­¢ä»»åŠ¡
            DownloadTaskContext ctx = activeContexts.get(id);
            if (ctx != null) {
                ctx.cancel();
                activeContexts.remove(id);
            }
            // åˆ é™¤æ–‡ä»¶
            if (deleteFile && record.getFileName() != null) {
                new File(record.getSavePath(), record.getFileName()).delete();
            }
            // åˆ é™¤è®°å½•
            repository.deleteById(id);
        }
    }
    
    @PostMapping("/{id}/{action}")
    public void control(@PathVariable String id, @PathVariable String action) {
        DownloadTaskContext ctx = activeContexts.get(id);
        // å¦‚æœå†…å­˜æ²¡æœ‰ï¼ˆä¾‹å¦‚é‡å¯åï¼‰ï¼Œéœ€é‡æ–°æ„å»ºContext (ç®€åŒ–å¤„ç†: åªæœ‰æ–°å»ºæˆ–ä¸€ç›´è¿è¡Œçš„ä»»åŠ¡åœ¨å†…å­˜)
        // å®Œæ•´ç‰ˆéœ€ä»DBé‡å»ºContext
        if(ctx == null) return;
        
        if("pause".equals(action)) ctx.pause();
        // resume é€»è¾‘éœ€é‡æ–°è§¦å‘ start
    }

    // å®šæ—¶æ¨é€æ•°æ®
    @Scheduled(fixedRate = 800)
    public void pushProgress() {
        List<Map<String, Object>> updates = new ArrayList<>();
        for (DownloadTaskContext ctx : activeContexts.values()) {
            updates.add(enrichRecordData(ctx.getRecord()));
        }
        if(!updates.isEmpty()) {
            messagingTemplate.convertAndSend("/topic/progress", updates);
        }
    }

    private Map<String, Object> enrichRecordData(DownloadRecord r) {
        Map<String, Object> map = new HashMap<>();
        map.put("id", r.getId());
        map.put("fileName", r.getFileName());
        map.put("url", r.getUrl());
        map.put("status", r.getStatus());
        map.put("totalSize", r.getTotalSize());
        map.put("createdTime", r.getCreatedTime());
        
        DownloadTaskContext ctx = activeContexts.get(r.getId());
        if (ctx != null) {
            map.put("status", ctx.getStatus()); // å®æ—¶çŠ¶æ€
            map.put("speed", ctx.getGlobalSpeed()); // å®æ—¶é€Ÿåº¦
            map.put("supportRange", ctx.isSupportRange());
            
            long downloaded = 0;
            for(ChunkInfo c : ctx.getChunkMap().values()) {
                downloaded += (c.getCurrent().get() - c.getStart());
            }
            map.put("downloaded", downloaded);
            // ä»…ä¼ è¾“ ChunkInfo å¿…è¦çš„å­—æ®µç»™å‰ç«¯ç»˜å›¾
            map.put("chunks", ctx.getChunkMap().values()); 
        } else {
            // ç¦»çº¿/å†å²ä»»åŠ¡
            map.put("speed", 0);
            map.put("downloaded", r.getTotalSize() == null ? 0 : r.getTotalSize());
        }
        return map;
    }
}
```

---

### 5. å‰ç«¯ UI V1.0.1 (ç¾è§‚çš„æ–¹å—å›¾)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Pro Downloader V1.0.1</title>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <script src="https://unpkg.com/@element-plus/icons-vue"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        body { background-color: #f5f7fa; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .main-container { max-width: 900px; margin: 20px auto; }
        
        /* å¯†é›†æ–¹å—å›¾æ ·å¼ */
        .grid-map {
            display: grid;
            grid-template-columns: repeat(20, 1fr); /* 20åˆ— */
            grid-template-rows: repeat(20, 15px);   /* 20è¡Œï¼Œå›ºå®šé«˜åº¦å½¢æˆæ­£æ–¹å½¢ */
            gap: 1px;
            background: #e4e7ed;
            border: 1px solid #dcdfe6;
            padding: 2px;
            margin-top: 10px;
        }
        .grid-cell {
            width: 100%;
            height: 100%;
            background-color: #fff;
            transition: background-color 0.2s;
        }
        
        /* ä»»åŠ¡å¡ç‰‡ */
        .task-card { margin-bottom: 15px; position: relative; }
        .task-info-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .task-title { font-weight: bold; font-size: 16px; color: #303133; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 60%; }
        .speed-badge { background: #409EFF; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; }
        
        /* é¢œè‰²æ± ï¼šä¸ºä¸åŒçº¿ç¨‹å‡†å¤‡çš„é¢œè‰² */
        .color-0 { background-color: #409EFF; }
        .color-1 { background-color: #67C23A; }
        .color-2 { background-color: #E6A23C; }
        .color-3 { background-color: #F56C6C; }
        .color-4 { background-color: #909399; }
        .color-5 { background-color: #a0cfff; }
        .color-6 { background-color: #b3e19d; }
        .color-7 { background-color: #f3d19e; }
        /* ... æ›´å¤šé¢œè‰²å¯ä»¥é€šè¿‡ JS åŠ¨æ€ç”Ÿæˆ HSL */
        .cell-finished { background-color: #67C23A !important; opacity: 1; }
    </style>
</head>
<body>
    <div id="app" class="main-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2>ğŸš€ Pro Downloader <small style="font-size: 14px; color: #999;">V1.0.1</small></h2>
            <el-button type="primary" @click="showCreateDialog = true" :icon="Plus">æ–°å»ºä»»åŠ¡</el-button>
        </div>

        <!-- ä»»åŠ¡åˆ—è¡¨ -->
        <div v-for="task in tasks" :key="task.id">
            <el-card class="task-card" shadow="hover">
                <!-- æ ‡é¢˜è¡Œ -->
                <div class="task-info-row">
                    <div class="task-title" :title="task.fileName">{{ task.fileName || task.url }}</div>
                    <div>
                        <span v-if="task.status === 'DOWNLOADING'" class="speed-badge">
                            âš¡ {{ formatSize(task.speed) }}/s
                        </span>
                        <el-tag size="small" :type="getStatusType(task.status)" style="margin-left: 10px;">{{ task.status }}</el-tag>
                    </div>
                </div>

                <!-- è¿›åº¦æ–‡å­— -->
                <div class="task-info-row" style="font-size: 13px; color: #606266;">
                    <span>
                        {{ formatSize(task.downloaded) }} / 
                        {{ task.totalSize > 0 ? formatSize(task.totalSize) : 'æœªçŸ¥å¤§å°' }}
                    </span>
                    <span>{{ formatPercent(task) }}%</span>
                </div>

                <!-- æ ¸å¿ƒå¯è§†åŒ–ï¼š400æ ¼æ–¹é˜µ (ä»…å½“å·²çŸ¥å¤§å°æ—¶æ˜¾ç¤º) -->
                <div v-if="task.totalSize > 0 && task.supportRange" class="grid-map">
                    <div v-for="(cell, idx) in getGridMap(task)" 
                         :key="idx" 
                         class="grid-cell"
                         :style="getCellStyle(cell)"
                         :title="cell.tip">
                    </div>
                </div>
                <!-- æµå¼ä¸‹è½½æ˜¾ç¤ºè¿›åº¦æ¡ -->
                <div v-else>
                     <el-progress :percentage="50" :indeterminate="true" :format="() => 'æµå¼ä¼ è¾“ä¸­...'" striped></el-progress>
                </div>

                <!-- æ“ä½œæ  -->
                <div style="margin-top: 15px; text-align: right;">
                    <el-button-group>
                        <el-button v-if="task.status === 'FINISHED'" type="success" size="small" @click="downloadToLocal(task)">
                            ğŸ“¥ å–å›æœ¬åœ°
                        </el-button>
                        <el-button v-if="task.status === 'DOWNLOADING'" type="warning" size="small" @click="control(task.id, 'pause')">æš‚åœ</el-button>
                        <el-button type="danger" size="small" @click="confirmDelete(task)">åˆ é™¤</el-button>
                    </el-button-group>
                </div>
            </el-card>
        </div>

        <!-- åˆ†é¡µ -->
        <el-pagination
            background
            layout="prev, pager, next"
            :total="totalTasks"
            :page-size="5"
            @current-change="handlePageChange"
            style="justify-content: center; margin-top: 20px;">
        </el-pagination>

        <!-- æ–°å»ºå¼¹çª— -->
        <el-dialog v-model="showCreateDialog" title="æ–°å»ºä¸‹è½½" width="500px">
            <el-form :model="form" label-width="80px">
                <el-form-item label="URL">
                    <el-input v-model="form.url" placeholder="https://..."></el-input>
                </el-form-item>
                <el-form-item label="ä¿å­˜è·¯å¾„">
                    <el-input v-model="form.path" placeholder="./downloads"></el-input>
                </el-form-item>
                <el-form-item label="çº¿ç¨‹æ•°">
                    <el-slider v-model="form.threads" :min="1" :max="32" show-input></el-slider>
                </el-form-item>
            </el-form>
            <template #footer>
                <el-button @click="showCreateDialog = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="createTask">å¼€å§‹ä¸‹è½½</el-button>
            </template>
        </el-dialog>
    </div>

    <script>
        const { createApp, ref, onMounted, computed } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;

        createApp({
            setup() {
                const tasks = ref([]);
                const totalTasks = ref(0);
                const currentPage = ref(1);
                const showCreateDialog = ref(false);
                const form = ref({ url: '', path: 'D:/Temp', threads: 8 }); // é»˜è®¤è·¯å¾„éœ€æ ¹æ®ç³»ç»Ÿè°ƒæ•´
                
                // é¢„å®šä¹‰é¢œè‰²æ±  (HSLç”Ÿæˆ)
                const colors = Array.from({length: 32}, (_, i) => `hsl(${i * 137.508}, 70%, 60%)`);

                const loadTasks = async (page = 1) => {
                    const res = await axios.get(`http://localhost:8080/api/download/list?page=${page-1}&size=5`);
                    // è¿™é‡Œåªæ›´æ–°å…ƒæ•°æ®ï¼Œå®æ—¶è¿›åº¦é WSåˆå¹¶
                    // ä¸ºé˜²æ­¢åˆ—è¡¨è·³åŠ¨ï¼Œä»…åˆå¹¶æ•°æ®ï¼Œä¸ç›´æ¥è¦†ç›–æ•°ç»„å¼•ç”¨ï¼ˆå¦‚æœIDåŒ¹é…ï¼‰
                    if(tasks.value.length === 0) {
                        tasks.value = res.data.content;
                    } else {
                        // ç®€å•å¤„ç†ï¼šç›´æ¥æ›¿æ¢ï¼Œwsä¼šè¡¥å…¨
                        tasks.value = res.data.content;
                    }
                    totalTasks.value = res.data.totalElements;
                };

                const connectWS = () => {
                    const socket = new SockJS('http://localhost:8080/ws');
                    const stomp = Stomp.over(socket);
                    stomp.debug = null;
                    stomp.connect({}, () => {
                        stomp.subscribe('/topic/progress', (msg) => {
                            const updates = JSON.parse(msg.body);
                            updates.forEach(u => {
                                const idx = tasks.value.findIndex(t => t.id === u.id);
                                if (idx !== -1) {
                                    // åˆå¹¶æ•°æ®ï¼Œä¿ç•™UIçŠ¶æ€
                                    tasks.value[idx] = { ...tasks.value[idx], ...u };
                                }
                            });
                        });
                    });
                };

                const createTask = async () => {
                    if(!form.value.url) return;
                    await axios.post('http://localhost:8080/api/download/start', form.value);
                    showCreateDialog.value = false;
                    loadTasks(1);
                    ElMessage.success('ä»»åŠ¡å·²åŠ å…¥é˜Ÿåˆ—');
                };

                const downloadToLocal = (task) => {
                    // æµè§ˆå™¨ç›´æ¥æ‰“å¼€æµåœ°å€
                    window.open(`http://localhost:8080/api/download/file/${task.id}`, '_blank');
                };
                
                const confirmDelete = (task) => {
                    ElMessageBox.confirm('æ˜¯å¦åŒæ—¶åˆ é™¤æœ¬åœ°æ–‡ä»¶?', 'åˆ é™¤ä»»åŠ¡', {
                        confirmButtonText: 'åˆ ä»»åŠ¡å’Œæ–‡ä»¶',
                        cancelButtonText: 'ä»…åˆ è®°å½•',
                        distinguishCancelAndClose: true,
                        type: 'warning'
                    }).then(() => {
                        axios.delete(`http://localhost:8080/api/download/${task.id}?deleteFile=true`).then(()=>loadTasks(currentPage.value));
                    }).catch((action) => {
                        if(action === 'cancel') {
                             axios.delete(`http://localhost:8080/api/download/${task.id}?deleteFile=false`).then(()=>loadTasks(currentPage.value));
                        }
                    });
                };

                // 400æ ¼å¯è§†åŒ–é€»è¾‘
                const getGridMap = (task) => {
                    const totalBlocks = 400; // 20x20
                    const cells = new Array(totalBlocks).fill(null);
                    if(!task.chunks) return cells;
                    
                    const bytesPerBlock = task.totalSize / totalBlocks;
                    
                    task.chunks.forEach(chunk => {
                        // è®¡ç®—è¯¥chunkè¦†ç›–çš„ block èŒƒå›´
                        const startIdx = Math.floor(chunk.start / bytesPerBlock);
                        const endIdx = Math.floor(chunk.end / bytesPerBlock);
                        const currentIdx = Math.floor(chunk.current / bytesPerBlock);
                        
                        // å¡«å……é¢œè‰²
                        for(let i = startIdx; i <= Math.min(endIdx, totalBlocks - 1); i++) {
                            let status = 'pending';
                            if(i < currentIdx) status = 'finished'; // å·²ä¸‹è½½åŒºåŸŸ
                            else if(i === currentIdx) status = 'downloading'; // æ­£åœ¨ä¸‹è½½çš„å¤´
                            
                            // å¦‚æœè¯¥æ ¼æœªè¢«å¡«å……æˆ–è¢«â€œæ›´æ´»è·ƒâ€çš„çŠ¶æ€è¦†ç›–
                            if(!cells[i] || status === 'downloading') {
                                cells[i] = {
                                    status: status,
                                    color: colors[chunk.colorIndex % 32],
                                    tip: `Thread ${chunk.colorIndex}`
                                };
                            }
                        }
                    });
                    return cells;
                };

                const getCellStyle = (cell) => {
                    if(!cell) return {}; // ç™½è‰²èƒŒæ™¯
                    if(cell.status === 'finished') return { backgroundColor: '#67C23A' }; // ç»Ÿä¸€ç»¿è‰²è¡¨ç¤ºå®Œæˆï¼Œæˆ–è€…ç”¨ cell.color ä½†åŠ æ·±
                    if(cell.status === 'downloading') return { backgroundColor: cell.color }; // çº¿ç¨‹è‰²
                    return { backgroundColor: '#eee' }; // ç°è‰²ç­‰å¾…
                };

                const formatSize = (size) => {
                    if(size==null || size<0) return 'Unknown';
                    if(size===0) return '0 B';
                    const k=1024, sizes=['B','KB','MB','GB'];
                    const i=Math.floor(Math.log(size)/Math.log(k));
                    return parseFloat((size/Math.pow(k,i)).toFixed(2))+' '+sizes[i];
                };
                
                const formatPercent = (task) => {
                    if(task.totalSize <= 0) return 0;
                    return ((task.downloaded / task.totalSize) * 100).toFixed(1);
                };
                
                const getStatusType = (s) => {
                    if(s==='FINISHED') return 'success';
                    if(s==='DOWNLOADING') return 'primary';
                    if(s==='ERROR') return 'danger';
                    return 'info';
                };

                onMounted(() => {
                    loadTasks();
                    connectWS();
                });

                return { 
                    tasks, totalTasks, showCreateDialog, form, 
                    createTask, handlePageChange: (p)=>{currentPage.value=p; loadTasks(p);},
                    downloadToLocal, confirmDelete, control: async (id, act)=> axios.post(`http://localhost:8080/api/download/${id}/${act}`),
                    getGridMap, getCellStyle, formatSize, formatPercent, getStatusType
                };
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>
```

### æ€»ç»“

è¿™ä¸ª V1.0.1 ç‰ˆæœ¬ä¸ä»…æ»¡è¶³äº†æ‚¨çš„æ–°éœ€æ±‚ï¼Œè¿˜ä¿®å¤äº†æ¶æ„ä¸Šçš„éšæ‚£ï¼š

1.  **å¯è§†åŒ–å‡çº§**ï¼š20x20 çš„ç½‘æ ¼ï¼Œæ­£åœ¨ä¸‹è½½çš„æ ¼å­ä¼šæ˜¾ç¤ºè¯¥çº¿ç¨‹å¯¹åº”çš„ä¸“å±é¢œè‰²ï¼ˆ`cell.color`ï¼‰ï¼Œä¸‹è½½å®Œçš„éƒ¨åˆ†å˜ä¸ºç»Ÿä¸€çš„ç»¿è‰²ã€‚è¿™æ¯”çº¯è¿›åº¦æ¡æ›´åƒ BitTorrent å®¢æˆ·ç«¯ã€‚
2.  **ä¸‹è½½é€Ÿåº¦**ï¼šåç«¯èšåˆè®¡ç®— `globalSpeed`ï¼Œå‰ç«¯åœ¨æ ‡é¢˜æ—æ˜¾ç¤ºè“è‰²å¾½ç«  `âš¡ 2.5 MB/s`ã€‚
3.  **æœ¬åœ°å–å›**ï¼šä¸‹è½½å®Œæˆåï¼Œç‚¹å‡»â€œå–å›æœ¬åœ°â€æŒ‰é’®ï¼Œé€šè¿‡æµè§ˆå™¨çš„ä¸‹è½½ç®¡ç†å™¨ä» Spring Boot ä¸‹è½½æ–‡ä»¶ã€‚
4.  **SQLite è®°å½•**ï¼šæ‰€æœ‰ä»»åŠ¡é‡å¯ä¸ä¸¢å¤±ï¼ŒæŒ‰æ—¶é—´å€’åºæ’åˆ—ï¼Œæ”¯æŒåˆ†é¡µã€‚
5.  **GitHub å…¼å®¹**ï¼šä»£ç è‡ªåŠ¨æ£€æµ‹ `Content-Length`ï¼Œå¦‚æœæ²¡æœ‰ï¼Œè‡ªåŠ¨é™çº§ä¸ºå•çº¿ç¨‹æµå¼ä¸‹è½½ï¼Œå‰ç«¯ UI è‡ªåŠ¨åˆ‡æ¢ä¸ºâ€œæµå¼ä¼ è¾“ä¸­...â€çš„æ¡å½¢è¿›åº¦ï¼Œé¿å…äº†å› é™¤ä»¥ 0 å¯¼è‡´çš„é”™è¯¯ã€‚