1. å› ä¸ºä¸‹è½½åœ¨æœåŠ¡ç«¯.ä¸‹è½½å®Œæˆå.å¢åŠ ç¦»çº¿ä¸‹è½½çš„åŠŸèƒ½
2. æ”¯æŒdockeréƒ¨ç½²,ä½¿ç”¨æœ€ç²¾ç®€çš„é•œåƒ
3. å¢åŠ é€‰æ‹©çº¿ç¨‹æ•°é‡.
4. æ”¯æŒä¸èƒ½rangeçš„åˆ†ç‰‡çš„æ™®é€šä¸‹è½½
5. ä¸‹è½½å®Œæˆå,ä¸‹è½½çš„æ–‡ä»¶åå°½é‡å’Œä¸‹è½½çš„urlä¿æŒä¸€è‡´,å¦‚https://aaa.com/aaa.pkg  -> ä¿å­˜ä¸ºaaa.pkg,å¦‚æœå½“å‰ç›®å½•ä¸‹é¢æœ‰é‡åçš„æ”¹ä¸ºaaa(1).pkg, aaa(2).pkg
6. é¡µé¢æœ€ä¸‹æ–¹å¢åŠ  çº¿ç¨‹æƒ…å†µä¸€è§ˆ,åƒbtè½¯ä»¶ä¸€æ ·èƒ½çœ‹åˆ°æ¯ä¸ªçº¿ç¨‹çš„èµ°åŠ¨ ä¸€ä¸ªå›ºå®šé•¿æ–¹å½¢, é‡Œé¢æœ‰å¾ˆå¤šå°æ ¼å­ ä¸€ä¸ªæ ¼å­ä»£è¡¨çº¿ç¨‹å½“å‰çš„ä½ç½®,å½“ä¸‹è½½å®Œæˆå,è¯¥æ ¼å­è‡ªåŠ¨å˜è‰²

I've been examining the user's request, specifically focusing on the new offline download requirement. My current thoughts revolve around expanding the Spring Boot file downloader's capabilities. I'm considering ways to manage these server-side downloads more efficiently and offer the user some control over the process. I am weighing different architectural approaches to handle this, as the initial design needs further enhancement.


**Optimizing Download Management**

I'm now zeroing in on the architecture. It seems persistence is key, though I'm debating between H2 and a simple JSON file for storing download progress. An in-memory static map, while quicker, wouldn't survive a server restart, and that's usually important for "offline" functionality. I'm also considering a minimalist Docker image, perhaps Alpine or Slim, to keep things lightweight. UI inputs will control thread count, and I'll build a fallback for servers not supporting range requests. URL parsing and duplicate filename handling are also in my sights. Finally, I'm thinking of adding a visual thread display.


**Expanding Offline Functionality**

I'm now integrating a `TaskStore` to retain download progress across browser disconnects, even if persistence isn't explicitly requested.  I'm upgrading the frontend to Vue 3 with Element Plus and refining the visualization logic to offer a more grid-like, BitTorrent-style display as requested. My refactoring will move from a single `currentTask` to a `Map<String, DownloadTaskContext>` for handling multiple downloads. I'm finalizing the Docker image with `openjdk:8-jre-alpine`.


**Refining Download Mechanics**

I'm presently tackling the specific implementation details. I'm focusing on minimizing the Docker image size by building with Maven and running with JRE Alpine. I've added `threadCount` to the start request parameters for user control. I'm also implementing the fallback mechanism for servers that don't support range requests, checking the `Accept-Ranges` header during file initialization. For filename handling, I'm extracting the filename from the URL and implementing a loop to ensure unique filenames. Finally, I'm finalizing the visual grid display, considering either a canvas or flex-wrap div and working on the backend data structure for `List<ChunkInfo>`.


**Designing the UI Elements**

I'm now fully immersed in the UI design. I'm focusing on a progress visualization that displays a file as a bar divided into chunks, with completed chunks green, downloading ones blue, and empty chunks gray. I'm also implementing a form for the user to select thread count and a task list to monitor ongoing downloads. I'm choosing between a canvas element and a flexible grid layout to represent the chunks. I am also working on creating the initial backend infrastructure to support the frontend changes.


**Refining Filename and Range Logic**

I'm now implementing the filename uniqueness logic, separating the filename from its extension to append a numerical suffix if a file with the same name already exists. I've also implemented the non-range request logic, setting the thread count to 1 if the server doesn't support range requests. Finally, I've updated the Docker build to use Maven for cleaner packaging. I'm moving toward the BitTorrent style visuals by mapping the file into 100 logical blocks, regardless of the number of threads, to provide the user with the "many small grids" display.


**Updating Progress Visualization**

I'm now zeroing in on the new visual progress display, which is key. I'm calculating the appropriate status for each block, determining whether to show it as green (complete), blue (active), or gray (empty). The frontend is going to use a consistent total of 100 blocks, allowing for consistent visuals even with different file sizes. I'm focusing on refining the block-to-chunk mapping to make sure the visuals are accurate and reflect download progress. I'm also ensuring the visuals remain consistent and reflect changes correctly.


**Structuring the Final Code**

I'm now putting the final pieces together, focusing on code organization.  My plan involves a `DownloadService` to control tasks, and a `DownloadTaskContext` handling the detailed download logic, including the filename check and single-thread fallback.  The `DownloadController` will expose the endpoints, and I'll update the `Dockerfile` to use a modern Java 8 Alpine image, specifically `eclipse-temurin:8-jre-alpine`. The final touches will involve updating the `index.html` file to match the newly designed UI.


Collapse to hide model thoughts
chevron_right
ä½ å¥½ï¼è¿™æ˜¯å¯¹ä¸Šä¸€ä¸ªç‰ˆæœ¬çš„æ·±åº¦è¿­ä»£ã€‚

ä¸ºäº†æ»¡è¶³æ‚¨çš„**â€œç¦»çº¿ä¸‹è½½â€**ï¼ˆæœåŠ¡ç«¯æŒä¹…åŒ–ä»»åŠ¡ï¼‰ã€**â€œDockerç²¾ç®€éƒ¨ç½²â€**ã€**â€œæ™ºèƒ½æ–‡ä»¶åå¤„ç†â€**ã€**â€œä¸æ”¯æŒRangeçš„é™çº§å¤„ç†â€**ä»¥åŠ**â€œBitTorrenté£æ ¼çš„å—çŠ¶å¯è§†åŒ–â€**éœ€æ±‚ï¼Œæˆ‘é‡æ„äº†æ¶æ„ã€‚

### æ ¸å¿ƒå˜æ›´ç‚¹
1.  **ä»»åŠ¡ç®¡ç†æœåŠ¡åŒ–**ï¼šä¸å†æ˜¯å•ä¾‹ï¼Œè€Œæ˜¯æ”¯æŒå¤šä»»åŠ¡ç®¡ç†çš„ `DownloadService`ï¼Œå‰ç«¯åˆ·æ–°é¡µé¢åå¯é‡è¿æŸ¥çœ‹è¿›åº¦ï¼ˆå³â€œç¦»çº¿ä¸‹è½½â€æ•ˆæœï¼‰ã€‚
2.  **æ™ºèƒ½IOç­–ç•¥**ï¼šè‡ªåŠ¨æ£€æµ‹ `Accept-Ranges`ï¼Œä¸æ”¯æŒåˆ†ç‰‡æ—¶è‡ªåŠ¨é™çº§ä¸ºå•çº¿ç¨‹æµå¼ä¸‹è½½ã€‚
3.  **æ–‡ä»¶åé˜²é‡**ï¼šå®ç°äº†ç±»ä¼¼æ“ä½œç³»ç»Ÿæ–‡ä»¶ç³»ç»Ÿçš„å‘½åå†²çªè§£å†³ç­–ç•¥ `abc(1).pkg`ã€‚
4.  **DockeråŒ–**ï¼šæä¾›ä¸¤é˜¶æ®µæ„å»ºçš„ Dockerfileï¼Œäº§å‡ºæå°çš„ Alpine é•œåƒã€‚
5.  **BitTorrent è§†è§‰å›¾**ï¼šå‰ç«¯å°†æ–‡ä»¶é€»è¾‘æ˜ å°„ä¸º 100 ä¸ª blockï¼Œæ ¹æ®åç«¯çš„åˆ†ç‰‡æ•°æ®å®æ—¶æ¸²æŸ“æ¯ä¸ª block çš„é¢œè‰²çŠ¶æ€ã€‚

---

### 1. åç«¯ä»£ç é‡æ„

#### 1.1 `pom.xml` (ä¿æŒä¸å˜ï¼Œä¾èµ–å¤Ÿç”¨äº†)

#### 1.2 å·¥å…·ç±»ï¼šæ–‡ä»¶åå¤„ç† `FileUtils.java`

```java
package com.example.downloader.util;

import java.io.File;
import java.net.URLDecoder;

public class FileUtils {

    /**
     * è·å–ä¸é‡å¤çš„æ–‡ä»¶å
     * ä¾‹å¦‚: test.zip -> test(1).zip -> test(2).zip
     */
    public static String getUniqueFileName(String savePath, String originalUrl) {
        String fileName = "unknown_file";
        try {
            // å°è¯•ä»URLè·å–æ–‡ä»¶å
            String decodedUrl = URLDecoder.decode(originalUrl, "UTF-8");
            int lastSlashIndex = decodedUrl.lastIndexOf('/');
            if (lastSlashIndex >= 0 && lastSlashIndex < decodedUrl.length() - 1) {
                fileName = decodedUrl.substring(lastSlashIndex + 1);
                // å»æ‰å¯èƒ½çš„URLå‚æ•°
                int questionMarkIndex = fileName.indexOf('?');
                if (questionMarkIndex > 0) {
                    fileName = fileName.substring(0, questionMarkIndex);
                }
            }
        } catch (Exception e) {
            // ignore
        }

        File file = new File(savePath, fileName);
        if (!file.exists()) {
            return fileName;
        }

        // åˆ†ç¦»æ–‡ä»¶åå’Œåç¼€
        String nameBody;
        String extension;
        int dotIndex = fileName.lastIndexOf('.');
        if (dotIndex > 0) {
            nameBody = fileName.substring(0, dotIndex);
            extension = fileName.substring(dotIndex);
        } else {
            nameBody = fileName;
            extension = "";
        }

        int counter = 1;
        while (true) {
            String newName = nameBody + "(" + counter + ")" + extension;
            file = new File(savePath, newName);
            if (!file.exists()) {
                return newName;
            }
            counter++;
        }
    }
}
```

#### 1.3 æ ¸å¿ƒä»»åŠ¡ç±» `DownloadTaskContext.java` (å‡çº§ç‰ˆ)

å¢åŠ äº†å•çº¿ç¨‹é™çº§é€»è¾‘å’Œæ–‡ä»¶åå¤„ç†ã€‚

```java
package com.example.downloader.core;

import com.example.downloader.model.ChunkInfo;
import com.example.downloader.model.DownloadStatus;
import com.example.downloader.util.FileUtils;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

@Slf4j
@Data
public class DownloadTaskContext {

    private final String taskId; // ä»»åŠ¡å”¯ä¸€æ ‡è¯†
    private final String downloadUrl;
    private final String savePath;
    private String fileName;     // å®é™…ä¿å­˜çš„æ–‡ä»¶å
    private long totalSize;
    private int threadCount;     // ç”¨æˆ·è¯·æ±‚çš„çº¿ç¨‹æ•°

    private volatile DownloadStatus status = DownloadStatus.IDLE;
    private boolean supportRange = true; // æ˜¯å¦æ”¯æŒæ–­ç‚¹ç»­ä¼ 

    private ForkJoinPool chunkExecutor;
    private final Map<String, ChunkInfo> chunkMap = new ConcurrentHashMap<>();
    private final Map<String, ChunkWorker> activeWorkers = new ConcurrentHashMap<>();
    private final Object fileLock = new Object();

    public DownloadTaskContext(String url, String path, int threadCount) {
        this.taskId = UUID.randomUUID().toString();
        this.downloadUrl = url;
        this.savePath = path;
        this.threadCount = threadCount;
        // é™åˆ¶æœ€å¤§å¹¶è¡Œåº¦ï¼Œé˜²æ­¢OOM
        this.chunkExecutor = new ForkJoinPool(Math.min(threadCount + 2, 64));
    }

    public void start() {
        if (status == DownloadStatus.DOWNLOADING || status == DownloadStatus.FINISHED) return;

        if (status == DownloadStatus.IDLE) {
            try {
                prepareFileAndCheckRange(); // 1. é¢„æ£€
                if (supportRange) {
                    splitChunks(this.threadCount); // 2. åˆ†ç‰‡
                } else {
                    // ä¸æ”¯æŒRangeï¼Œåˆ›å»ºä¸€ä¸ªè¦†ç›–å…¨æ–‡ä»¶çš„å•ä»»åŠ¡
                    log.warn("æœåŠ¡å™¨ä¸æ”¯æŒRangeï¼Œé™çº§ä¸ºå•çº¿ç¨‹ä¸‹è½½");
                    this.threadCount = 1;
                    ChunkInfo singleChunk = new ChunkInfo("SINGLE", 0, totalSize - 1, 0);
                    chunkMap.put(singleChunk.getId(), singleChunk);
                }
            } catch (IOException e) {
                log.error("åˆå§‹åŒ–å¤±è´¥", e);
                status = DownloadStatus.ERROR;
                return;
            }
        }

        status = DownloadStatus.DOWNLOADING;
        chunkMap.values().stream()
                .filter(c -> !c.isFinished())
                .forEach(this::submitTask);

        startMonitor();
    }

    public void pause() {
        if (status == DownloadStatus.DOWNLOADING) {
            status = DownloadStatus.PAUSED;
            activeWorkers.values().forEach(ChunkWorker::stopWork);
            activeWorkers.clear();
        }
    }

    public void cancel() {
        status = DownloadStatus.CANCELED;
        activeWorkers.values().forEach(ChunkWorker::stopWork);
        activeWorkers.clear();
        // å°è¯•åˆ é™¤æ–‡ä»¶
        if (fileName != null) {
            new File(savePath, fileName).delete();
        }
    }

    private void prepareFileAndCheckRange() throws IOException {
        CloseableHttpClient client = HttpClients.createDefault();
        // å…ˆç”¨ Head è¯·æ±‚æ£€æŸ¥ Headerï¼Œå¦‚æœ Head è¢«ç¦ç”¨åˆ™å°è¯• Get
        HttpHead headRequest = new HttpHead(downloadUrl);
        
        try (CloseableHttpResponse response = client.execute(headRequest)) {
            int statusCode = response.getStatusLine().getStatusCode();
            if (statusCode != 200) {
                // å¦‚æœ Head å¤±è´¥ï¼Œå°è¯• Get (Range: 0-0)
                 // å®é™…ç”Ÿäº§ç¯å¢ƒåº”æœ‰æ›´å¤æ‚çš„ Fallback é€»è¾‘ï¼Œè¿™é‡Œç®€åŒ–
                 if(statusCode == 405) { /* Method Not Allowed, try GET */ }
            }
            
            // 1. æ£€æŸ¥æ˜¯å¦æ”¯æŒ Range
            if (response.containsHeader("Accept-Ranges")) {
                String val = response.getFirstHeader("Accept-Ranges").getValue();
                this.supportRange = "bytes".equalsIgnoreCase(val);
            } else {
                // æœ‰äº›æœåŠ¡å™¨ä¸è¿”å› Accept-Ranges ä½†å®é™…æ”¯æŒï¼Œè¿™é‡Œä¸ºäº†ç¨³å¦¥ï¼Œè‹¥æ²¡è¿”å›åˆ™è§†ä¸ºä¸æ”¯æŒ
                this.supportRange = false;
            }

            // 2. è·å–å¤§å°
            if (response.containsHeader("Content-Length")) {
                this.totalSize = Long.parseLong(response.getFirstHeader("Content-Length").getValue());
            } else {
                // æ— æ³•è·å–å¤§å°æ—¶ï¼Œä¹Ÿæ— æ³•è¿›è¡Œå¤šçº¿ç¨‹åˆ†ç‰‡
                this.totalSize = -1; // Stream download
                this.supportRange = false;
            }

            // 3. ç¡®å®šæ–‡ä»¶å
            this.fileName = FileUtils.getUniqueFileName(savePath, downloadUrl);
            log.info("Task [{}] å°†ä¿å­˜ä¸º: {}", taskId, fileName);

            // 4. å ä½æ–‡ä»¶
            if (this.totalSize > 0) {
                File file = new File(savePath, fileName);
                if (!file.getParentFile().exists()) file.getParentFile().mkdirs();
                try (RandomAccessFile raf = new RandomAccessFile(file, "rw")) {
                    raf.setLength(this.totalSize);
                }
            }
        }
    }

    private void splitChunks(int count) {
        long blockSize = totalSize / count;
        for (int i = 0; i < count; i++) {
            long start = i * blockSize;
            long end = (i == count - 1) ? totalSize - 1 : (i + 1) * blockSize - 1;
            ChunkInfo chunk = new ChunkInfo(UUID.randomUUID().toString(), start, end, start);
            chunkMap.put(chunk.getId(), chunk);
        }
    }

    // ... tryRebalance() é€»è¾‘ä¿æŒä¸å˜ ...
    public void tryRebalance() {
        // å¦‚æœä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ ï¼Œåˆ™ä¸èƒ½è¿›è¡ŒåŠ¨æ€é‡åˆ†é…
        if (!supportRange) return;
        
        // å¤ç”¨ä¹‹å‰çš„é€»è¾‘...
        List<ChunkInfo> activeChunks = chunkMap.values().stream()
                .filter(c -> !c.isFinished())
                .collect(Collectors.toList());

        if (activeChunks.size() > 3 || activeChunks.isEmpty()) return;
        long currentMaxSpeed = activeChunks.stream().mapToLong(ChunkInfo::getSpeed).max().orElse(1);
        
        for (ChunkInfo slowChunk : activeChunks) {
            long remaining = slowChunk.getEnd() - slowChunk.getCurrent().get();
            if (remaining < 10 * 1024 * 1024) continue; // å‰©ä½™å°äº10MBä¸åˆ‡åˆ†

            if (slowChunk.getSpeed() < (currentMaxSpeed * 0.2)) {
                performSplit(slowChunk);
                break;
            }
        }
    }
    
    private synchronized void performSplit(ChunkInfo parentChunk) {
        ChunkWorker worker = activeWorkers.get(parentChunk.getId());
        if (worker != null) {
            worker.stopWork();
            activeWorkers.remove(parentChunk.getId());
        }
        long currentPos = parentChunk.getCurrent().get();
        long endPos = parentChunk.getEnd();
        long mid = currentPos + (endPos - currentPos) / 2;
        parentChunk.setEnd(mid);
        ChunkInfo newChunk = new ChunkInfo(UUID.randomUUID().toString(), mid + 1, endPos, mid + 1);
        chunkMap.put(newChunk.getId(), newChunk);
        submitTask(parentChunk);
        submitTask(newChunk);
    }

    private void submitTask(ChunkInfo chunkInfo) {
        ChunkWorker worker = new ChunkWorker(chunkInfo);
        activeWorkers.put(chunkInfo.getId(), worker);
        chunkExecutor.execute(worker);
    }

    private void startMonitor() {
        new Thread(() -> {
            while (status == DownloadStatus.DOWNLOADING) {
                try {
                    Thread.sleep(1000);
                    // è®¡ç®—é€Ÿåº¦
                    boolean allFinished = true;
                    for (ChunkInfo chunk : chunkMap.values()) {
                        if (!chunk.isFinished()) {
                            allFinished = false;
                            long curr = chunk.getCurrent().get();
                            long speed = curr - chunk.getLastRecordBytes();
                            chunk.setSpeed(speed);
                            chunk.setLastRecordBytes(curr);
                        } else {
                            chunk.setSpeed(0);
                        }
                    }
                    if (allFinished && !chunkMap.isEmpty()) {
                        status = DownloadStatus.FINISHED;
                        break;
                    }
                    tryRebalance();
                } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
            }
        }).start();
    }

    // å†…éƒ¨ Worker ç±»ï¼Œå¢åŠ å¯¹ä¸æ”¯æŒ Range çš„å¤„ç†
    private class ChunkWorker extends RecursiveAction {
        private final ChunkInfo chunkInfo;
        private final AtomicBoolean running = new AtomicBoolean(true);

        public ChunkWorker(ChunkInfo chunkInfo) { this.chunkInfo = chunkInfo; }
        public void stopWork() { running.set(false); }

        @Override
        protected void compute() {
            while (running.get() && !chunkInfo.isFinished() && chunkInfo.getErrorCount() < 5) {
                try { download(); } catch (Exception e) {
                    chunkInfo.setErrorCount(chunkInfo.getErrorCount() + 1);
                    try { Thread.sleep(1000); } catch (InterruptedException ignored) {}
                }
            }
        }

        private void download() throws IOException {
            long startPos = chunkInfo.getCurrent().get();
            long endPos = chunkInfo.getEnd();

            CloseableHttpClient client = HttpClients.createDefault();
            HttpGet request = new HttpGet(downloadUrl);
            
            // åªæœ‰å½“æ”¯æŒ Range æ—¶æ‰æ·»åŠ  header
            if (supportRange) {
                request.addHeader("Range", "bytes=" + startPos + "-" + endPos);
            }

            try (CloseableHttpResponse response = client.execute(request);
                 InputStream is = response.getEntity().getContent();
                 RandomAccessFile raf = new RandomAccessFile(new File(savePath, fileName), "rw")) {

                // å¦‚æœä¸æ”¯æŒ Rangeï¼Œå¿…é¡»ä»å¤´å†™å…¥ï¼ˆæˆ–è€…ä½¿ç”¨è¿½åŠ æµï¼Œä½†è¿™é‡Œç®€åŒ–ä¸ºå•çº¿ç¨‹ç‹¬å ï¼‰
                if (supportRange) {
                    raf.seek(startPos);
                } else {
                    raf.seek(0); // ä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ ï¼Œæ¯æ¬¡éƒ½ä»å¤´å¼€å§‹
                }

                byte[] buffer = new byte[8192];
                int len;
                while (running.get() && (len = is.read(buffer)) != -1) {
                    synchronized (fileLock) {
                        if (supportRange) raf.seek(chunkInfo.getCurrent().get());
                        else raf.seek(chunkInfo.getCurrent().get()); // å•çº¿ç¨‹ä¹Ÿéœ€è¦ç»´æŠ¤ä½ç½®
                        
                        raf.write(buffer, 0, len);
                    }
                    chunkInfo.getCurrent().addAndGet(len);
                }
                
                // åˆ¤å®šå®Œæˆé€»è¾‘
                if (supportRange) {
                    if (chunkInfo.getCurrent().get() >= chunkInfo.getEnd()) chunkInfo.setFinished(true);
                } else {
                    // ä¸æ”¯æŒ Range æ—¶ï¼Œæµè¯»å®Œå°±ç®—å®Œæˆ
                    chunkInfo.setFinished(true);
                }
            }
        }
    }
}
```

#### 1.4 `DownloadService` (ç®¡ç†å¤šä»»åŠ¡)

```java
package com.example.downloader.service;

import com.example.downloader.core.DownloadTaskContext;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class DownloadService {
    // å†…å­˜ä»»åŠ¡åº“ï¼Œé‡å¯åä¸¢å¤±ï¼ˆå¦‚éœ€å®Œå…¨ç¦»çº¿æŒä¹…åŒ–ï¼Œæ­¤å¤„åº”è¿æ¥æ•°æ®åº“ï¼‰
    private final Map<String, DownloadTaskContext> taskStore = new ConcurrentHashMap<>();

    public DownloadTaskContext createTask(String url, String path, int threads) {
        DownloadTaskContext task = new DownloadTaskContext(url, path, threads);
        taskStore.put(task.getTaskId(), task);
        return task;
    }

    public DownloadTaskContext getTask(String taskId) {
        return taskStore.get(taskId);
    }

    public Collection<DownloadTaskContext> getAllTasks() {
        return taskStore.values();
    }
}
```

#### 1.5 `DownloadController` (é€‚é…å¤šä»»åŠ¡)

```java
package com.example.downloader.controller;

import com.example.downloader.core.DownloadTaskContext;
import com.example.downloader.model.ChunkInfo;
import com.example.downloader.service.DownloadService;
import lombok.Data;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/download")
@CrossOrigin
public class DownloadController {

    @Autowired
    private DownloadService downloadService;

    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    @PostMapping("/start")
    public String start(@RequestBody DownloadRequest req) {
        DownloadTaskContext task = downloadService.createTask(req.getUrl(), req.getPath(), req.getThreads());
        task.start();
        return task.getTaskId();
    }

    @PostMapping("/action/{taskId}/{action}")
    public void control(@PathVariable String taskId, @PathVariable String action) {
        DownloadTaskContext task = downloadService.getTask(taskId);
        if (task == null) return;
        
        switch (action) {
            case "pause": task.pause(); break;
            case "resume": task.start(); break;
            case "cancel": task.cancel(); break;
        }
    }

    // è·å–æ‰€æœ‰ä»»åŠ¡åˆ—è¡¨ï¼ˆç”¨äºç¦»çº¿é‡è¿ï¼‰
    @GetMapping("/list")
    public Collection<Map<String, Object>> listTasks() {
        return downloadService.getAllTasks().stream().map(this::convertTaskToDto).collect(Collectors.toList());
    }

    @Scheduled(fixedRate = 1000)
    public void broadcastStatus() {
        Collection<DownloadTaskContext> tasks = downloadService.getAllTasks();
        List<Map<String, Object>> statusList = tasks.stream()
                .map(this::convertTaskToDto)
                .collect(Collectors.toList());
        
        if (!statusList.isEmpty()) {
            // æ¨é€ç»™è®¢é˜…è€…ï¼Œå‰ç«¯è¿‡æ»¤è‡ªå·±å…³å¿ƒçš„ taskId
            messagingTemplate.convertAndSend("/topic/tasks", statusList);
        }
    }

    private Map<String, Object> convertTaskToDto(DownloadTaskContext task) {
        Map<String, Object> map = new HashMap<>();
        map.put("id", task.getTaskId());
        map.put("fileName", task.getFileName());
        map.put("url", task.getDownloadUrl());
        map.put("status", task.getStatus());
        map.put("totalSize", task.getTotalSize());
        map.put("supportRange", task.isSupportRange());
        
        long downloaded = 0;
        for (ChunkInfo c : task.getChunkMap().values()) {
            downloaded += (c.getCurrent().get() - c.getStart());
        }
        map.put("downloaded", downloaded);
        map.put("chunks", task.getChunkMap().values());
        return map;
    }

    @Data
    public static class DownloadRequest {
        private String url;
        private String path;
        private int threads;
    }
}
```

---

### 2. Docker éƒ¨ç½²

åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹åˆ›å»º `Dockerfile`ã€‚

```dockerfile
# ç¬¬ä¸€é˜¶æ®µï¼šæ„å»º (ä½¿ç”¨ maven:3.8-jdk-8-slim ä»¥å‡å°ä½“ç§¯)
FROM maven:3.8.6-openjdk-8-slim AS build
WORKDIR /app
COPY ../pom.xml .
COPY ../src ./src
# è·³è¿‡æµ‹è¯•ä»¥åŠ å¿«æ„å»º
RUN mvn clean package -DskipTests

# ç¬¬äºŒé˜¶æ®µï¼šè¿è¡Œ (ä½¿ç”¨æç®€ Alpine JRE)
# eclipse-temurin æ˜¯ç›®å‰æ¨èçš„ OpenJDK å‘è¡Œç‰ˆ
FROM eclipse-temurin:8-jre-alpine
WORKDIR /app

# è®¾ç½®æ—¶åŒº (å¯é€‰ï¼Œæ–¹ä¾¿æŸ¥çœ‹æ—¥å¿—æ—¶é—´)
RUN apk add --no-cache tzdata
ENV TZ=Asia/Shanghai

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶ jar åŒ…
COPY --from=build /app/target/*.jar app.jar

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¯åŠ¨å‚æ•°
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**æ„å»ºå‘½ä»¤**ï¼š
```bash
docker build -t java-downloader .
docker run -d -p 8080:8080 -v /data/downloads:/data/downloads java-downloader
```

---

### 3. å‰ç«¯å‡çº§ (Vue 3 + BitTorrent é£æ ¼å¯è§†åŒ–)

è¿™ä¸ªå‰ç«¯ä»£ç åŒ…å«äº†ä¸€ä¸ªå¤æ‚çš„ç®—æ³•ï¼šå°†ä»»æ„æ•°é‡çš„çº¿ç¨‹åˆ†ç‰‡æ˜ å°„åˆ°å›ºå®šæ•°é‡ï¼ˆ100ä¸ªï¼‰çš„å¯è§†åŒ–ç½‘æ ¼ä¸­ã€‚

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Java ForkJoin ä¸‹è½½å™¨ (Pro)</title>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        /* BT é£æ ¼å¯è§†åŒ–æ ·å¼ */
        .bit-map-container {
            display: flex;
            flex-wrap: wrap;
            width: 100%;
            background: #eee;
            border: 1px solid #ddd;
            padding: 2px;
        }
        .bit-block {
            width: 1%; /* 100ä¸ªæ ¼å­ï¼Œæ¯ä¸ª1% */
            height: 15px;
            box-sizing: border-box;
            border: 1px solid #fff;
            background-color: #e0e0e0; /* é»˜è®¤ç°è‰² */
            transition: background-color 0.3s;
        }
        .bit-block.finished { background-color: #67C23A; } /* ç»¿è‰²å®Œæˆ */
        .bit-block.downloading { background-color: #409EFF; } /* è“è‰²è¿›è¡Œä¸­ */
        .bit-block.pending { background-color: #909399; } 
        
        .task-card { margin-bottom: 20px; }
        .task-header { display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold;}
    </style>
</head>
<body>
    <div id="app" style="padding: 20px; max-width: 1200px; margin: 0 auto;">
        <h1>ğŸš€ ç¦»çº¿ä¸‹è½½ç®¡ç†å™¨ (Docker Ready)</h1>
        
        <!-- æ–°å»ºä»»åŠ¡åŒºåŸŸ -->
        <el-card class="box-card">
            <template #header><span>æ–°å»ºä»»åŠ¡</span></template>
            <el-form :inline="true" :model="form">
                <el-form-item label="URL">
                    <el-input v-model="form.url" placeholder="http://..." style="width: 400px;"></el-input>
                </el-form-item>
                <el-form-item label="ä¿å­˜è·¯å¾„">
                    <el-input v-model="form.path" placeholder="/data/downloads"></el-input>
                </el-form-item>
                <el-form-item label="çº¿ç¨‹æ•°">
                    <el-input-number v-model="form.threads" :min="1" :max="32"></el-input-number>
                </el-form-item>
                <el-form-item>
                    <el-button type="primary" @click="createTask">ç«‹å³ä¸‹è½½</el-button>
                </el-form-item>
            </el-form>
        </el-card>

        <div style="margin-top: 20px;"></div>

        <!-- ä»»åŠ¡åˆ—è¡¨ -->
        <div v-for="task in tasks" :key="task.id">
            <el-card class="task-card">
                <div class="task-header">
                    <span>ğŸ“„ {{ task.fileName || 'è·å–ä¸­...' }} ({{ formatSize(task.totalSize) }})</span>
                    <div>
                        <el-tag>{{ task.status }}</el-tag>
                        <el-button size="small" @click="controlTask(task.id, 'pause')" v-if="task.status === 'DOWNLOADING'">æš‚åœ</el-button>
                        <el-button size="small" @click="controlTask(task.id, 'resume')" v-if="task.status === 'PAUSED'">ç»§ç»­</el-button>
                        <el-button size="small" type="danger" @click="controlTask(task.id, 'cancel')">å–æ¶ˆ</el-button>
                    </div>
                </div>

                <div style="margin-bottom: 5px;">
                    è¿›åº¦: {{ formatSize(task.downloaded) }} / {{ formatSize(task.totalSize) }}
                    <span v-if="!task.supportRange" style="color: red; font-size: 12px;">(ä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ )</span>
                </div>

                <!-- BT é£æ ¼å¯è§†åŒ– -->
                <div class="bit-map-container">
                    <div 
                        v-for="(blockStatus, index) in getBitMap(task)" 
                        :key="index" 
                        class="bit-block" 
                        :class="blockStatus"
                        :title="'Block ' + index">
                    </div>
                </div>
                
                <!-- çº¿ç¨‹é€Ÿåº¦æ¦‚è§ˆ -->
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                   æ´»è·ƒçº¿ç¨‹æ•°: {{ task.chunks.filter(c => !c.finished).length }} | 
                   åŠ¨æ€åˆ‡åˆ†: {{ task.chunks.length }} ä¸ªåˆ†ç‰‡
                </div>
            </el-card>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted } = Vue;

        createApp({
            setup() {
                const form = ref({
                    url: 'https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso', // æµ‹è¯•å¤§æ–‡ä»¶
                    path: '/tmp',
                    threads: 8
                });
                const tasks = ref([]);

                // WebSocket è¿æ¥
                const connectWS = () => {
                    const socket = new SockJS('http://localhost:8080/ws');
                    const stompClient = Stomp.over(socket);
                    stompClient.debug = null;
                    stompClient.connect({}, () => {
                        stompClient.subscribe('/topic/tasks', (msg) => {
                            const serverTasks = JSON.parse(msg.body);
                            // æ›´æ–°æœ¬åœ°åˆ—è¡¨ï¼Œä¿æŒé¡ºåº
                            tasks.value = serverTasks.reverse(); 
                        });
                    });
                };

                const createTask = async () => {
                    await axios.post('http://localhost:8080/api/download/start', form.value);
                    ElementPlus.ElMessage.success('ä»»åŠ¡å·²åˆ›å»º');
                };

                const controlTask = async (id, action) => {
                    await axios.post(`http://localhost:8080/api/download/action/${id}/${action}`);
                };

                /**
                 * æ ¸å¿ƒå¯è§†åŒ–ç®—æ³•
                 * å°†æ–‡ä»¶æ€»å¤§å°æ˜ å°„ä¸º 100 ä¸ªæ ¼å­
                 */
                const getBitMap = (task) => {
                    const blocks = new Array(100).fill(''); 
                    if (!task.totalSize || task.totalSize <= 0) return blocks;
                    if (!task.chunks) return blocks;

                    const blockSize = task.totalSize / 100;

                    // éå†æ¯ä¸ª Blockï¼Œåˆ¤æ–­å®ƒå±äºå“ªä¸ª Chunkï¼Œä»¥åŠè¯¥ Chunk æ˜¯å¦å®Œæˆ
                    for (let i = 0; i < 100; i++) {
                        const blockStart = i * blockSize;
                        const blockEnd = (i + 1) * blockSize;
                        
                        // æ‰¾åˆ°è¦†ç›–å½“å‰ block èŒƒå›´çš„æ‰€æœ‰ chunk (é€šå¸¸æ˜¯ä¸€ä¸ªï¼Œä½†åœ¨è¾¹ç•Œå¯èƒ½æ˜¯ä¸¤ä¸ª)
                        // ç®€åŒ–é€»è¾‘ï¼šçœ‹ block çš„ä¸­å¿ƒç‚¹è½åœ¨å“ªä¸ª chunk é‡Œ
                        const blockCenter = blockStart + (blockSize / 2);

                        const chunk = task.chunks.find(c => 
                            blockCenter >= c.start && blockCenter <= c.end
                        );

                        if (chunk) {
                            if (chunk.finished) {
                                blocks[i] = 'finished';
                            } else {
                                // æ£€æŸ¥å½“å‰ä¸‹è½½è¿›åº¦æ˜¯å¦è¦†ç›–äº†è¿™ä¸ª block
                                // chunk.current æ˜¯ç»å¯¹ä½ç½®
                                if (chunk.current > blockEnd) {
                                    blocks[i] = 'finished'; // å·²ç»ä¸‹è½½è¿‡äº†
                                } else if (chunk.current > blockStart) {
                                    blocks[i] = 'downloading'; // æ­£åœ¨ä¸‹è½½è¿™ä¸ªå—
                                } else {
                                    blocks[i] = 'pending'; // è¿˜æ²¡ä¸‹è½½åˆ°è¿™é‡Œ
                                }
                            }
                        }
                    }
                    return blocks;
                };

                const formatSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                onMounted(async () => {
                    // åˆå§‹åŒ–å…ˆè·å–ä¸€æ¬¡åˆ—è¡¨
                    const res = await axios.get('http://localhost:8080/api/download/list');
                    tasks.value = res.data;
                    connectWS();
                });

                return { form, tasks, createTask, controlTask, getBitMap, formatSize };
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>
```

### å®ç°æ•ˆæœè¯´æ˜

1.  **BitTorrent è§†è§‰å›¾**ï¼š
    *   é¡µé¢ä¸Šä¸å†æ˜¯ä¸€æ¡æ¡é•¿è¿›åº¦æ¡ï¼Œè€Œæ˜¯ä¸€ä¸ªç”± 100 ä¸ªå°æ–¹å—ç»„æˆçš„é•¿æ–¹å½¢ã€‚
    *   **ç°è‰²**ï¼šç­‰å¾…ä¸­ã€‚
    *   **è“è‰²**ï¼šçº¿ç¨‹æ­£åœ¨å¤„ç†è¯¥åŒºåŸŸï¼ˆCurrent æŒ‡é’ˆç»è¿‡è¯¥ Blockï¼‰ã€‚
    *   **ç»¿è‰²**ï¼šè¯¥åŒºåŸŸå·²å†™å…¥ç£ç›˜ã€‚
    *   å½“çº¿ç¨‹æ•°è®¾ä¸º 8 æ—¶ï¼Œä½ ä¼šçœ‹åˆ° 8 ä¸ªè“è‰²çš„ç‚¹åœ¨ç½‘æ ¼ä¸­ç§»åŠ¨ï¼Œåé¢ç•™ä¸‹ä¸€ç‰‡ç»¿è‰²ã€‚

2.  **ç¦»çº¿ä¸é‡è¿**ï¼š
    *   åç«¯ä½¿ç”¨ `DownloadService` ç»´æŠ¤æ‰€æœ‰ä»»åŠ¡ã€‚
    *   å‰ç«¯ `onMounted` æ—¶å…ˆæ‹‰å– `/list`ï¼Œéšåé€šè¿‡ WebSocket å®æ—¶æ›´æ–°ã€‚å³ä½¿ç”¨æˆ·å…³é—­æµè§ˆå™¨å†æ‰“å¼€ï¼Œä¹Ÿèƒ½ç«‹åˆ»çœ‹åˆ°ä¹‹å‰çš„ä¸‹è½½çŠ¶æ€ã€‚

3.  **æ–‡ä»¶åæ™ºèƒ½å¤„ç†**ï¼š
    *   åç«¯ `FileUtils.getUniqueFileName` ä¼šæ£€æµ‹ `aaa.pkg` æ˜¯å¦å­˜åœ¨ï¼Œå­˜åœ¨åˆ™è‡ªåŠ¨é‡å‘½åä¸º `aaa(1).pkg`ï¼Œç¡®ä¿ä¸ä¼šè¦†ç›–æ—§æ–‡ä»¶ã€‚

4.  **Docker æç®€**ï¼š
    *   ä½¿ç”¨ `eclipse-temurin:8-jre-alpine`ï¼Œé•œåƒå¤§å°é€šå¸¸åœ¨ 80MB-100MB å·¦å³ï¼Œéå¸¸é€‚åˆå¾®æœåŠ¡éƒ¨ç½²ã€‚

5.  **é Range é™çº§**ï¼š
    *   ä»£ç æ£€æµ‹ Headerï¼Œå¦‚æœæ²¡æœ‰ `Accept-Ranges`ï¼Œåˆ™å¼ºåˆ¶ `threads=1`ï¼Œå¹¶ä½¿ç”¨ `raf.seek(0)` è¿›è¡Œå•çº¿ç¨‹å†™å…¥ï¼Œå‰ç«¯ä¼šæ˜¾ç¤ºâ€œä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ â€çš„çº¢è‰²æç¤ºã€‚
        104.5s
        Use Arrow Up and Arrow Down to select a turn, Enter to jump to it, and Escape to return to the chat.
        Response ready.
