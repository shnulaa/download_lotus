<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Pro Downloader V1.0.1</title>
    <link rel="stylesheet" href="css/element-plus.css">
    <script src="js/vue.global.js"></script>
    <script src="js/element-plus.js"></script>
    <script src="js/icons-vue.js"></script>
    <script src="js/sockjs.min.js"></script>
    <script src="js/stomp.min.js"></script>
    <script src="js/axios.min.js"></script>
    <style>
        body {
            background-color: #f5f7fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .main-container {
            max-width: 900px;
            margin: 20px auto;
        }

        /* å¯†é›†æ–¹å—å›¾æ ·å¼ */
        .grid-map {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            /* 20åˆ— */
            grid-template-rows: repeat(20, 15px);
            /* 20è¡Œï¼Œå›ºå®šé«˜åº¦å½¢æˆæ­£æ–¹å½¢ */
            gap: 1px;
            background: #e4e7ed;
            border: 1px solid #dcdfe6;
            padding: 2px;
            margin-top: 10px;
        }

        .grid-cell {
            width: 100%;
            height: 100%;
            background-color: #fff;
            transition: background-color 0.2s;
        }

        /* ä»»åŠ¡å¡ç‰‡ */
        .task-card {
            margin-bottom: 15px;
            position: relative;
        }

        .task-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .task-title {
            font-weight: bold;
            font-size: 16px;
            color: #303133;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 60%;
        }

        .speed-badge {
            background: #409EFF;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* é¢œè‰²æ± ï¼šä¸ºä¸åŒçº¿ç¨‹å‡†å¤‡çš„é¢œè‰² */
        .color-0 {
            background-color: #409EFF;
        }

        .color-1 {
            background-color: #67C23A;
        }

        .color-2 {
            background-color: #E6A23C;
        }

        .color-3 {
            background-color: #F56C6C;
        }

        .color-4 {
            background-color: #909399;
        }

        .color-5 {
            background-color: #a0cfff;
        }

        .color-6 {
            background-color: #b3e19d;
        }

        .color-7 {
            background-color: #f3d19e;
        }

        /* ... æ›´å¤šé¢œè‰²å¯ä»¥é€šè¿‡ JS åŠ¨æ€ç”Ÿæˆ HSL */
        .cell-finished {
            background-color: #67C23A !important;
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="app" class="main-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2>ğŸš€ Download Lotus <small style="font-size: 14px; color: #999;">V1.0.2</small></h2>
            <div style="display: flex; align-items: center; gap: 10px;">
                <el-tag size="small"
                    :type="wsStatus === 'connected' ? 'success' : wsStatus === 'connecting' ? 'warning' : 'danger'"
                    :title="wsError">
                    {{ wsStatus === 'connected' ? 'ğŸŸ¢ å·²è¿æ¥' : wsStatus === 'connecting' ? 'ğŸŸ¡ è¿æ¥ä¸­' : 'ğŸ”´ æ–­å¼€ (' + wsError
                    + ')' }}
                </el-tag>
                <el-button type="primary" @click="showCreateDialog = true" :icon="Plus">æ–°å»ºä»»åŠ¡</el-button>
            </div>
        </div>

        <!-- ä»»åŠ¡åˆ—è¡¨ -->
        <div v-for="task in tasks" :key="task.id">
            <el-card class="task-card" shadow="hover">
                <!-- æ ‡é¢˜è¡Œ -->
                <div class="task-info-row">
                    <div class="task-title" :title="task.fileName">{{ task.fileName || task.url }}</div>
                    <div>
                        <span v-if="task.status === 'DOWNLOADING'" class="speed-badge">
                            âš¡ {{ formatSize(task.speed) }}/s
                        </span>
                        <el-tag size="small" :type="getStatusType(task.status)" style="margin-left: 10px;">{{
                            task.status }}</el-tag>
                    </div>
                </div>

                <!-- è¿›åº¦æ–‡å­— -->
                <div class="task-info-row" style="font-size: 13px; color: #606266;">
                    <span>
                        {{ formatSize(task.downloaded) }} /
                        {{ task.totalSize > 0 ? formatSize(task.totalSize) : 'æœªçŸ¥å¤§å°' }}
                    </span>
                    <span>{{ formatPercent(task) }}%</span>
                    <el-link type="primary" :underline="false" @click="task.showGrid = !task.showGrid"
                        v-if="task.totalSize > 0 && task.supportRange" style="margin-left: 15px;">
                        {{ task.showGrid ? 'æ”¶èµ·åŒºå—' : 'æŸ¥çœ‹åŒºå—' }}
                        <el-icon class="el-icon--right">
                            <component :is="task.showGrid ? 'ArrowUp' : 'ArrowDown'" />
                        </el-icon>
                    </el-link>
                </div>

                <!-- æ ¸å¿ƒå¯è§†åŒ–ï¼š400æ ¼æ–¹é˜µ (ä»…å½“å·²çŸ¥å¤§å°æ—¶æ˜¾ç¤º) -->
                <div v-if="task.showGrid && task.totalSize > 0 && task.supportRange" class="grid-map">
                    <div v-for="(cell, idx) in getGridMap(task)" :key="idx" class="grid-cell"
                        :style="getCellStyle(cell)" :title="cell.tip">
                    </div>
                </div>
                <!-- æµå¼ä¸‹è½½æ˜¾ç¤ºè¿›åº¦æ¡ -->
                <div v-else-if="task.status === 'DOWNLOADING' && task.totalSize <= 0">
                    <el-progress :percentage="100" :indeterminate="true" :format="() => 'æµå¼ä¼ è¾“ä¸­...'"
                        striped></el-progress>
                </div>
                <!-- æµå¼ä¸‹è½½å®Œæˆ -->
                <div v-else-if="task.status === 'FINISHED' && task.totalSize <= 0">
                    <el-progress :percentage="100" status="success" :format="() => 'å·²å®Œæˆ'" striped></el-progress>
                </div>

                <!-- æ“ä½œæ  -->
                <div style="margin-top: 15px; text-align: right;">
                    <el-button-group>
                        <el-button v-if="task.status === 'FINISHED'" type="success" size="small"
                            @click="downloadToLocal(task)">
                            ğŸ“¥ å–å›æœ¬åœ°
                        </el-button>
                        <el-button type="primary" size="small" @click="copyDownloadLink(task)">
                            ğŸ“‹ å¤åˆ¶ä¸‹è½½é“¾æ¥
                        </el-button>
                        <el-button v-if="task.status === 'DOWNLOADING'" type="warning" size="small"
                            @click="control(task.id, 'pause')">æš‚åœ</el-button>
                        <el-button type="danger" size="small" @click="confirmDelete(task)">åˆ é™¤</el-button>
                    </el-button-group>
                </div>
            </el-card>
        </div>

        <!-- åˆ†é¡µ -->
        <el-pagination background layout="prev, pager, next" :total="totalTasks" :page-size="5"
            @current-change="handlePageChange" style="justify-content: center; margin-top: 20px;">
        </el-pagination>

        <!-- æ–°å»ºå¼¹çª— -->
        <el-dialog v-model="showCreateDialog" title="æ–°å»ºä¸‹è½½" width="500px">
            <el-form :model="form" label-width="80px">
                <el-form-item label="URL">
                    <el-input v-model="form.url" placeholder="https://..."></el-input>
                </el-form-item>
                <el-form-item label="çº¿ç¨‹æ•°">
                    <el-slider v-model="form.threads" :min="1" :max="32" show-input></el-slider>
                </el-form-item>
            </el-form>
            <template #footer>
                <el-button @click="showCreateDialog = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="createTask">å¼€å§‹ä¸‹è½½</el-button>
            </template>
        </el-dialog>
    </div>

    <script>
        const { createApp, ref, onMounted, computed } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;

        createApp({
            setup() {
                const tasks = ref([]);
                const totalTasks = ref(0);
                const currentPage = ref(1);
                const showCreateDialog = ref(false);
                const wsStatus = ref('disconnected'); // WebSocketè¿æ¥çŠ¶æ€: connecting, connected, disconnected
                const wsError = ref('');
                const msgCount = ref(0);
                const wsClient = ref(null);
                const reconnectTimer = ref(null);
                const form = ref({ url: 'https://officecdn-microsoft-com.akamaized.net/pr/C1297A47-86C4-4C1F-97FA-950631F94777/MacAutoupdate/Microsoft_Office_16.55.21111400_BusinessPro_Installer.pkg', threads: 8 });

                // é¢„å®šä¹‰é¢œè‰²æ±  (HSLç”Ÿæˆ)
                const colors = Array.from({ length: 32 }, (_, i) => `hsl(${i * 137.508}, 70%, 60%)`);

                const loadTasks = async (page = 1) => {
                    const res = await axios.get(`/api/download/list?page=${page - 1}&size=5`);
                    // è¿™é‡Œåªæ›´æ–°å…ƒæ•°æ®ï¼Œå®æ—¶è¿›åº¦é WSåˆå¹¶
                    // ä¸ºé˜²æ­¢åˆ—è¡¨è·³åŠ¨ï¼Œä»…åˆå¹¶æ•°æ®ï¼Œä¸ç›´æ¥è¦†ç›–æ•°ç»„å¼•ç”¨ï¼ˆå¦‚æœIDåŒ¹é…ï¼‰
                    if (tasks.value.length === 0) {
                        tasks.value = res.data.content.map(t => ({ ...t, showGrid: false }));
                    } else {
                        // ç®€å•å¤„ç†ï¼šç›´æ¥æ›¿æ¢ï¼Œwsä¼šè¡¥å…¨
                        tasks.value = res.data.content.map(t => ({ ...t, showGrid: false }));
                    }
                    totalTasks.value = res.data.totalElements;
                };

                const connectWS = () => {
                    wsStatus.value = 'connecting';
                    wsError.value = '';

                    const socket = new SockJS('http://localhost:8080/ws');
                    const stomp = Stomp.over(socket);
                    stomp.debug = null;

                    stomp.connect({},
                        () => {
                            wsStatus.value = 'connected';
                            wsClient.value = stomp;
                            console.log('WebSocketè¿æ¥æˆåŠŸ');

                            // è®¢é˜…è¿›åº¦æ›´æ–°
                            stomp.subscribe('/topic/progress', (msg) => {
                                // console.log('WS Recv:', msg.body); // Debug log
                                msgCount.value++;
                                const updates = JSON.parse(msg.body);
                                updates.forEach(u => {
                                    const idx = tasks.value.findIndex(t => t.id === u.id);
                                    if (idx !== -1) {
                                        // åˆå¹¶æ•°æ®ï¼Œä¿ç•™UIçŠ¶æ€
                                        tasks.value[idx] = { ...tasks.value[idx], ...u };
                                    }
                                });
                            });

                            // è¿æ¥æˆåŠŸåç«‹å³åŠ è½½ä»»åŠ¡åˆ—è¡¨
                            loadTasks();
                        },
                        (error) => {
                            wsStatus.value = 'error';
                            wsError.value = error.toString();
                            console.error('WebSocketè¿æ¥å¤±è´¥:', error);
                            // 5ç§’åé‡è¿
                            setTimeout(connectWS, 5000);
                        }
                    );
                    socket.onclose = () => {
                        if (wsStatus.value === 'connected') {
                            wsStatus.value = 'disconnected';
                            console.log('WebSocketè¿æ¥å…³é—­ï¼Œå°è¯•é‡è¿...');
                            reconnectTimer.value = setTimeout(() => {
                                connectWS();
                            }, 3000);
                        }
                    };
                };

                const createTask = async () => {
                    if (!form.value.url) return;
                    // ç¡®ä¿å§‹ç»ˆä½¿ç”¨å›ºå®šè·¯å¾„
                    const payload = { ...form.value, path: './Temp' };
                    const response = await axios.post('/api/download/start', payload);
                    const taskId = response.data;

                    // ç«‹å³åˆ›å»ºä¸´æ—¶ä»»åŠ¡å¯¹è±¡å¹¶æ·»åŠ åˆ°åˆ—è¡¨å‰ç«¯ï¼Œå®ç°å®æ—¶æ˜¾ç¤º
                    const tempTask = {
                        id: taskId,
                        fileName: null,
                        url: form.value.url,
                        status: 'IDLE',
                        totalSize: -1,
                        downloaded: 0,
                        speed: 0,
                        createdTime: new Date().toISOString(),
                        supportRange: false,
                        showGrid: false
                    };
                    tasks.value.unshift(tempTask);
                    totalTasks.value++;

                    showCreateDialog.value = false;
                    ElMessage.success('ä»»åŠ¡å·²åˆ›å»º');
                };

                const downloadToLocal = (task) => {
                    // æµè§ˆå™¨ç›´æ¥æ‰“å¼€æµåœ°å€
                    window.open(`http://localhost:8080/api/download/file/${task.id}`, '_blank');
                };

                const copyDownloadLink = (task) => {
                    const downloadUrl = task.url;
                    navigator.clipboard.writeText(downloadUrl).then(() => {
                        ElMessage.success('ä¸‹è½½é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    }).catch(() => {
                        ElMessage.error('å¤åˆ¶å¤±è´¥');
                    });
                };

                const confirmDelete = (task) => {
                    ElMessageBox.confirm('æ˜¯å¦åŒæ—¶åˆ é™¤æœ¬åœ°æ–‡ä»¶?', 'åˆ é™¤ä»»åŠ¡', {
                        confirmButtonText: 'åˆ ä»»åŠ¡å’Œæ–‡ä»¶',
                        cancelButtonText: 'ä»…åˆ è®°å½•',
                        distinguishCancelAndClose: true,
                        type: 'warning'
                    }).then(() => {
                        axios.delete(`http://localhost:8080/api/download/${task.id}?deleteFile=true`).then(() => loadTasks(currentPage.value));
                    }).catch((action) => {
                        if (action === 'cancel') {
                            axios.delete(`http://localhost:8080/api/download/${task.id}?deleteFile=false`).then(() => loadTasks(currentPage.value));
                        }
                    });
                };

                // 400æ ¼å¯è§†åŒ–é€»è¾‘
                const getGridMap = (task) => {
                    const totalBlocks = 400; // 20x20
                    const cells = new Array(totalBlocks).fill(null);

                    // å¦‚æœä»»åŠ¡å·²å®Œæˆï¼Œä»ç„¶æ˜¾ç¤ºæ¯ä¸ªçº¿ç¨‹çš„é¢œè‰²ï¼ˆè€Œä¸æ˜¯å…¨ç»¿ï¼‰
                    const isFinished = task.status === 'FINISHED';

                    if (!task.chunks) {
                        // å¦‚æœæ²¡æœ‰chunksä¿¡æ¯ä½†å·²å®Œæˆï¼Œæ˜¾ç¤ºå…¨ç»¿
                        if (isFinished) {
                            return cells.fill({ status: 'finished', color: '#67C23A', tip: 'Completed' });
                        }
                        return cells;
                    }

                    // ç¡®ä¿ chunks æ˜¯æ•°ç»„
                    const chunks = Array.isArray(task.chunks) ? task.chunks : Object.values(task.chunks);

                    const bytesPerBlock = task.totalSize / totalBlocks;

                    chunks.forEach(chunk => {
                        // è®¡ç®—è¯¥chunkè¦†ç›–çš„ block èŒƒå›´
                        const startIdx = Math.floor(chunk.start / bytesPerBlock);
                        const endIdx = Math.floor(chunk.end / bytesPerBlock);

                        // å…¼å®¹å¤„ç† AtomicLong åºåˆ—åŒ–é—®é¢˜
                        const currentVal = (typeof chunk.current === 'number') ? chunk.current : (chunk.currentPos || 0);
                        const currentIdx = Math.floor(currentVal / bytesPerBlock);

                        // å¡«å……é¢œè‰²
                        for (let i = startIdx; i <= Math.min(endIdx, totalBlocks - 1); i++) {
                            let status = 'pending';
                            if (isFinished || i < currentIdx) {
                                status = 'finished'; // å·²å®Œæˆæˆ–å·²ä¸‹è½½åŒºåŸŸ
                            } else if (i === currentIdx) {
                                status = 'downloading'; // æ­£åœ¨ä¸‹è½½çš„å¤´
                            }

                            // å¦‚æœè¯¥æ ¼æœªè¢«å¡«å……æˆ–è¢«"æ›´æ´»è·ƒ"çš„çŠ¶æ€è¦†ç›–
                            if (!cells[i] || status === 'downloading') {
                                cells[i] = {
                                    status: status,
                                    color: colors[chunk.colorIndex % 32],
                                    tip: `Thread ${chunk.colorIndex}`
                                };
                            }
                        }
                    });
                    return cells;
                };

                const getCellStyle = (cell) => {
                    if (!cell) return {}; // ç™½è‰²èƒŒæ™¯
                    // å·²å®Œæˆçš„æ–¹å—æ˜¾ç¤ºçº¿ç¨‹é¢œè‰²ï¼ˆç¨å¾®åŠ æ·±é€æ˜åº¦ä»¥ç¤ºåŒºåˆ«ï¼‰
                    if (cell.status === 'finished') return { backgroundColor: cell.color, opacity: 0.8 };
                    if (cell.status === 'downloading') return { backgroundColor: cell.color }; // çº¿ç¨‹è‰²
                    return { backgroundColor: '#eee' }; // ç°è‰²ç­‰å¾…
                };

                const formatSize = (size) => {
                    if (size == null || size < 0) return 'Unknown';
                    if (size === 0) return '0 B';
                    const k = 1024, sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(size) / Math.log(k));
                    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                const formatPercent = (task) => {
                    if (task.totalSize <= 0) return 0;
                    return ((task.downloaded / task.totalSize) * 100).toFixed(1);
                };

                const getStatusType = (s) => {
                    if (s === 'FINISHED') return 'success';
                    if (s === 'DOWNLOADING') return 'primary';
                    if (s === 'ERROR') return 'danger';
                    return 'info';
                };

                onMounted(() => {
                    loadTasks();
                    connectWS();
                });

                return {
                    tasks, totalTasks, showCreateDialog, form, wsStatus, wsError, msgCount,
                    createTask, handlePageChange: (p) => { currentPage.value = p; loadTasks(p); },
                    downloadToLocal, copyDownloadLink, confirmDelete, control: async (id, act) => axios.post(`http://localhost:8080/api/download/${id}/${act}`),
                    getGridMap, getCellStyle, formatSize, formatPercent, getStatusType
                };
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>

</html>